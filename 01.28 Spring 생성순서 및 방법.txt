<Spring 생성순서 및 방법>

1. DTO(Data Transfer Object) 
- 데이터 전송 객체
- 스프링과 DB 테이블의 데이터를 주고 받을 수 있게 해주는 객체
- DB테이블의 컬럼정보를 저장할 수 있는 멤버변수를 생성하는 곳!

2. xml
- 쿼리문을 작성하는 곳!
- namespace에는 xml 파일과 연결할 mapper interface 파일명을 패키지까지 포함해서 작성해야함.
- resultType, resultMap : 쿼리 실행 결과를 조회되는 하나의 행 데이터를 저장할 변수를 정함.
- resultType : 실행 결과 데이터가 자바에서 제공하는 자료형으로 받을 수 있을 때 사용
- resultMap : 실행 결과 데이터를 우리가 만든 자료형(클래스 자료형)으로 받을 때 사용
  ->데이터베이스 테이블에서 조회된 데이터를 spring 으로 가져올 자료형을 매칭
- resultMap = " id " => id와 일치

3. Mapper Interface
- 목적 : xml에서 만든 쿼리를 실행할 추상메서드 선언(빈 껍데기만 존재, 실제로 실행X)
 <초기세팅>
 1) xml 파일과 Mapper Interface 연결 -> xml 파일의 namespace부분임
 2) 인터페이스 위에 @Mapper 어노테이션 적용
  -> 객체 생성 + 해당 인터페이스가 쿼리를 실행시키는 메서드가 있는 파일이야 라고 스프링에게 알려줌
 3) 쿼리를 실행할 추상메서드 선언
 4) 메서드 선언에는 메서드명, 리턴타입, 매개변수 정보 작성
  -> 메서드명 : 실행할 쿼리문의 id와 같은 값으로 작성
  -> 리턴타입 : 쿼리 실행결과 전체 데이터를 받을 수 있는 자료형으로 작성
                    : 조회(SELECT) 일 경우 -> 조회된 데이터에 따라 리턴타입이 달라짐.
                    : 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 일 경우 -> void, int 로 리턴타입이 결정됨.
  -> void : 조회되는 데이터가 없기 때문에 사용 가능
  -> int : 쿼리 실행에 영향을 받은 행의 갯수
  -> 매개변수 : 쿼리 실행 시 빈 값을 채울 수 있는 데이터

4. Service
- 목적 : 인터페이스에서 선언한 추상메서드를 실행할 메서드 구현
- 실제 쿼리 기능을 구현할 클래스임(몸통)
 <초기세팅>
 1) @Service 어노테이션을 클래스명 위에 선언 
   -> 객체생성 + 이 클래스가 핵심기능이 구현된 클래스라는 것을 스프링에게 알려줌.
 2) 쿼리 실행 메서드를 호출하기 위해 Mapper 인터페이스에 대한 객체를  의존성 주입받아야 함,
  2-1) Mapper 인터페이스 객체를 멤버변수로 선언
  2-2) 생성자 의존성 주입 문법을 사용하여 Mapper 인터페이스 객체를 생성
   -> @AutoWired : 생성자 의존성 주입, 생성자가 하나라면 생략이 가능(=자동으로 생성되어 있음)

5. Controller
- 목적 : 해당파일은 요청에 대한 응답기능을 구현(API)
- 응답으로 주로 쿼리를 실행을 함 -> 서비스에서 만든 메서드를 가져와서 실행하겠다.
 <초기세팅>
 1) 클래스 위에 @RestController 어노테이션을 선언
  -> 객체 생성 + 이 클래스가 요청에 대한 응답을 처리하는 클래스임을 스프링에게 알려줌.
 2) 쿼리 실행 기능 메서드를 호출하기 위해 
  2-1) Service 클래스의 객체를 멤버변수로 선언
  2-2) 생성자 의존성 주입 문법을 사용해서 Service 객체를 생성
