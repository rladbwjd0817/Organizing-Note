<DB & SPRING 연동>

1. 데이터베이스 테이블 생성(BASIC_BOARD)
2. DTO 클래스 생성
3. 데이터베이스 테이블과 DTO 클래스를 연결하는 <resultMap>태그를 xml 파일에 생성
--- 4번 부터 반복 ----
4. 실행 할 쿼리는 xml 파일에 작성
5. Mapper interface에 방금 만든 쿼리를 실행할 추상메서드를 작성
6. Service 클래스에 추상메서드를 구현하여 기능을 작성 
7. Service 클래스에 쿼리 기능을 수행하는 메서드 구현
8. Controller 클래스에 Service 클래스에서 만든 메서드를 실행
=====================================================================
< 2. DTO 클래스 생성 >

* DTO : Data Transfer Object - 데이터 전송 객체
  -> DB 테이블과 자바가 서로 데이터를 주고 받을 수 있는 클래스

* 테이블의 각 컬럼에 매칭되는 멤버변수 만들어 주기
  -> 멤버변수명은 반드시 테이블의 컬럼명을 기준으로 작성, 카멜표기법으로 언더바 제거하고, 언더바 뒤 첫 글자는 대문자로 표기

* 멤버변수 생성 후 모든 멤버변수에 대한 getter, setter, toString 어노테이션 만들어주기

* DB 'DATETIME' -> Java 'java.time.LocalDateTime' 으로 선언 

★ _____DTO 객체 하나는 DB 테이블에서 하나의 행 데이터를 저장할 수 있음(한줄 다) ★

=====================================================================
<3. 데이터베이스 테이블과 DTO 클래스를 연결하는 <resultMap>태그를 xml 파일에 생성 >

*  ______mapper.xml 파일의 mapper 태그 안에 코드를 작성
ex)
<mapper namespace= "com.green.basic_board.mapper.BoardMapper">
   => namespace에는 xml 파일과 연결할 Mapper interface 파일명을 패키지를 포함하여 기입
  <resultMap id= "board" type="com.green.basic_board.dto.BoardDTO">
      => type : " "를 연결하겠습니다
	<id column= "BOARD_NUM" property="boardNum"/>
	<result column= "TITLE" property="title"/>
	<result column= "WRITER" property="writer"/>
	<result column= "CONTENT" property="content"/>
	<result column= "READ_CNT" property="readCnt"/>
	<result column= "CREATE_DATE" property="createDate"/>  
	  =>DB에서 column의 값을 조회하면 boardDTO 안에 있는 변수에 하나씩 저장.
  </resultMap>

# 해석 #
- BOARD_NUM 컬럼이 조회되면 BoardDTO 클래스의 boardNum 변수에 데이터를 받아오겠다.
- TITLE 컬럼이 조회되면 BoardDTO 클래스의 title 변수에 데이터를 받아오겠다.
- WRITER컬럼이 조회되면 BoardDTO 클래스의 writer 변수에 받아오겠다.
- 나머지 반복,,,,,,
 - 이렇게 DB에서 조회된 데이터를 받아오는 것을 board라고 부르겠다.

* column 속성에는 DB 테이블의 컬럼명을 작성, property에는 조회된 데이터를 자바로 가져올 클래스의 멤버변수명을 작성
  -> DB 테이블 컬럼명 = JAVA 멤버변수명

* <resultMap> 태그의 id 속성은 여러 쿼리문을 구분하기 위한 식별자 - 중복 X, 
  type 속성은 조회된 데이터를 가져올 클래스명을 패키지명과 함께 작성한 것

=====================================================================
<4. xml에 실행할 쿼리 작성 >

* 실행할 모든 쿼리문은 XML 파일의 <mapper></mapper> 태그 안에 작성

ex)
 <mapper namespace= "com.green.basic_board.mapper.BoardMapper">
   <resultMap id= "board" type="com.green.basic_board.dto.BoardDTO">
     .....
   //쿼리실행 메서드
   

</mapper>

* SELECT 쿼리문 : <select></select>태그안, INSERT 쿼리문 : <insert></insert>,
  UPDATE 쿼리문 : <update></update>, DELETE 쿼리문 : <delete></delete>

* resultMap, resultType 속성은 DB에서 조회 결과 데이터 한 행을 자바의 어떤 자료형에 담을지 지정하는 속성 
   ->SELECT에만 있음. INSERT, UPDATE, DELETE는 조회 결과가 없기에 작성 X

* resultType : 조회 결과 데이터가 int, double, String 과 같이 자바에서 기본적으로 제공하는 자료형으로 받을 수 있으면 사용
* resultMap :  조회 결과 데이터가 자바에서 제공하는 자료형이 아닌 클래스 자료형으로 받을 수 있으면 사용

ex)
<select id="getReadCnt" resultType="int">
	SELECT READ_CNT
	FROM BASIC_BOARD
	WHERE BOARD_NUM = 1
</select> 

=> 출력결과 : BASIC_BOARD 테이블에서 글번호가 1인 조회수를 조회 
      -> 데이터 1개 조회 -> DB 데이터를 자바 int 자료형으로 조회된 데이터를 받을 수 있음!

<select id="getReadCntAll" resultType="int">
	SELECT READ_CNT
	FROM BASIC_BOARD
</select> 

=> 출력결과 : BASIC_BOARD에서 전체 조회수를 조회 
       -> 결과로 여러 행이 나와도 한 행만 데이터를 받을 수 있기에 조회수는 정수라 자바 int로 데이터를 받을 수 있음! 
       -> 그래서 resultType 사용

ex)
 <select id="test3" resultMap="board">
        SELECT BOARD_NUM
            	, TITLE
            	, CONTENT
            	, WRITER
        FROM BASIC_BOARD
        WHERE BOARD_NUM = #{boardNum}
 </select>

=>출력결과 : BASIC_BOARD에서 boardNum 변수에서 받은 데이터와 같은 글번호의 글번호, 제목, 내용, 작가를 조회
    -> 만약 boardNum = 2 ;  
    -> 글번호 : 2, 제목 : "어린 왕자", 내용 : "장미꽃", 작가  : 생텍쥐베리  -> 한 행으로 조회
    -> 자바 자료형에서 한 행을 한 번에 넣을 자료형은 없기에 사용자가 만들어둔 DTO 클래스 자료형을 이용!
       ---> DTO 클래스에 DB 테이블의 컬럼명과 같은 멤버변수가 생성되어 있어서 가능!
       ---> 그래서 resultMap 을 사용!

    -> #{변수} : 쿼리문에서 사용하는 자바 변수 
    -> 변수명은 내가 넣을 데이터와 같은 이름을 가진 컬럼으로 넣어주기

★ resultType에 작성되는 자료형은 조회되는 모든 데이터를 자바로 가져오기 위한 자료형을 작성하는 것이 아니라
    조회되는 모든 데이터 중 하나의 행 데이터를 담을 수 있는 자료형을 작성 ★
★ 조회되는 컬럼의 이름과 resultMap 속성에 작성한 클래스의 멤버변수명이 일치하는 데이터만 가져오고,
    별칭으로 조회하거나, SELECT에 없는 컬럼은 기본값을 가짐. ★
=====================================================================
<5. Mapper Interface에서 방금 만든 쿼리를 실행할 추상메서드 작성 >

* Mapper Interface는 DB 테이블과 관련된 쿼리문을 실행할 목적의 추상메서드를 정의하는 공간
* 쿼리만 실행!

* Interface 클래스 위에 @Mapper 어노테이션 생성 
   -> 객체 생성 + xml 파일에서 만든 쿼리문을 실행시키는 인터페이스라는 것을 지정

★ mapper interface에 작성하는 추상 메서드명은 반드시 xml에 작성한 쿼리의 id 속성과 일치해야 함!!★

* 추상메서드의 매개변수는 작성한 쿼리문에서 변수의 값을 채우는 용도로 사용 -> 매개변수는 작성한 쿼리문에 따라 유동적으로 달라짐

★ 추상메서드 리턴타입 : 쿼리 실행 후 전체 결과 데이터를 받아 올 수 있는 자료형으로 선언 ★
★ 메서드의 매개변수 : 쿼리 실행 시 채워줘야 하는 데이터
      -> 쿼리가 완성본이면 채워줘야 할 게 없기에 매개변수는 빈칸으로 놔둠.

ex)     <xml>                                                                         <mapper>
<select id="test2" resultType="int">    =========>         List<Integer> test2( );
        SELECT BOARD_NUM
        FROM BASIC_BOARD
</select>

  => 출력결과 : 글 번호 전체(여러 데이터)

ex)           <xml>                                                                         <mapper>
<select id="test3" resultMap="board">    =========>             BoardDTO test3(int boardNum);
        SELECT BOARD_NUM
            	, TITLE
            	, CONTENT
            	, WRITER
        FROM BASIC_BOARD
        WHERE BOARD_NUM = #{boardNum}
 </select>

 =>출력결과 : boardNum = 2;
 => 글번호 : 2, 제목 : "어린 왕자", 내용 : "장미꽃", 작가  : 생텍쥐베리 
  -> 한 행만 조회되니 List<>쓰지 않고, 테이블 컬럼과 같은 멤버변수가 있는 BoardDTO 클래스로 리턴 
  -> 행이 여러 행으로 조회되면 그땐 List<> 사용!
 => 쿼리문에서 변수로 인해 빠져있는 부분은 mapper에서 매개변수 자리에 넣어서 채워줘야 함!

=====================================================================
<6. Service 클래스에 추상메서드를 구현하여 기능을 작성>

* Service class : 프로젝트에서 핵심기능을 구현한 클래스(DB기능)
* @Service : 객체 생성 어노테이션

1) 쿼리 실행 추상메서드가 존재하는 객체를 선언! 
  -> private BoardMapper boardMapper;  
      => 같은 자료형으로 만들어져 있는 객체를 @Autowired로 인해 객체가 저장됨. 

2) 생성자 생성 
   @Autowired   //생성자 의존성 주입
   public BoardService(BoardMapper boardMapper){
  	this.boardMapper = boardMapper;
   }

Q. @Autowired 쓰는 이유는?
 -> 인터페이스 안에 실제 조회 쿼리를 실행하는 메서드를 정의했고, 그 메서드를 사용해야 하기 때문에!
      메서드 호출은 객체명.메서드( ) 라서 객체가 필요해서 @Autowired 사용!
=====================================================================
<7. Service 클래스에 쿼리 기능을 수행하는 메서드 구현>

3) Mapper interface에 정의된 추상메서드를 실행할 메서드 생성 

ex)  
   public List<Integer> runTest2( ){
   	List<Integer> result2 = boardMapper.test2();
    	return result2;
   }  
   
  => return 해줘야 하고, 리턴타입도 맞춰줘야 함!
  => return에 실행결과가 저장되어 있음!
  => return에는 조회된 글번호 전체 목록 데이터를 가진 List 객체를 리턴 
        -> return된 글번호 목록 데이터를 받아서 사용가능

 ex)
   public BoardDTO runTest3(int boardNum){
    	BoardDTO result3 = boardMapper.test3(boardNum); //=> 쿼리 실행
    	return result3;
   }
  
  => Mapper에서 채워진 매개변수를 Service에서 그대로 매개변수로 넣어줘야 함!
 
=====================================================================
<8. Conroller 클래스에 Service 클래스에서 만든 메서드를 실행>

1) 클래스위에 @RestController 어노테이션 실행 -> 객체 생성 기능 있음
2) 객체선언 : private BoardService boardService;
3) 생성자 생성 
ex)
 @Autowired 
  public BoardController(BoardService boardService){
    this.boardService = boardService; //this. = 이 클래스에서 정의된 ~~
  }

-> @Autowired : 생성자 의존성 주입, 매개변수로 전달받을 수 있는 자료형이 있는지 확인하고 있으면 전달해줌.
4) API 생성
ex)
@GetMapping("/test2")
  public List<Integer> test2( ){
    List<Integer> result2 = boardService.runTest2( );
    return result2;
  }

ex)
@GetMapping("/test3/{boardNum}")
  public BoardDTO test3(@PathVariable("boardNum") int boardNum){
    BoardDTO result3 = boardService.runTest3(boardNum);
    return result3;
  } 
 => 매개변수는 쿼리 빈 값 채워주는 용도!
=====================================================================

* AUTO_INCREMENT : 알아서 데이터 넣어줌. 하나의 데이터 구분하는 기능
@Autowired : 생성자 의존성 주입, 매개변수로 전달받을 수 있는 자료형이 있는지 확인하고 있으면 전달해줌.
=====================================================================
★ 요약 ★
DB 테이블 -> DTO 클래스 -> xml -> Mapper(interface - 추상메서드) -> Service(구현) -> Controller(메서드 호출)

