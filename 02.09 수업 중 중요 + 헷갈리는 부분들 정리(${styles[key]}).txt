<수업 중 중요 + 헷갈리는 부분들 정리>

* props 활용!!
 - 객체임.
 - 매개변수를 객체로 전달.
 - 부모컴포넌트 -> 자식컴포넌트에 값을 전달하는 단방향 데이터 전달방식
ex)
className={`${styles.button} ${styles.primary}`}
-> ` ` 안에 띄어쓰기하고 클래스 하나씩 적용가능함

* <Button title = '검색' variant = 'success'/>
variant -> 속성 값 바꾸기 시전

ex)
const Button = ({ -------------------------------------------------------> 큰 틀은 구조분해할당 O
  title = '버튼', ------------------------------------------------------------>객체 형태로 들어와서 key, value 형태로 적용되며, <Button /> 안에 별다른 설정이 없으면 { }안의 key와 value가 기본값으로 설정됨.
  variant = 'purple', 
  size = 'small', 
  ...props ------------------------------------------------------------------->구조분해할당 X, 위의 키 값들 빼고 나머지 키 값의 데이터를 다 받음.
}) => {
  return (
    <button 
    type='button'
    className={` ${styles.button} ${styles[variant]} ${styles[size]} `} ------------------>`` 백틱안에 ${ } 로 변수 여러개를 className으로 설정 가능
    {...props} ---------------------------------------------------------------------------->스프레드연산자를 활용해 props의 데이터를 새로운 객체로 생성 
    >
      {title}
    </button>
  )
}
=======================================================================================
* ${styles[variant]} => [ ] 는 key값을 변수처럼 활용

* <Button 
          title = '중복확인' 
          variant = 'purple' -------------------------> Button컴포넌트의 className 중 variant 변수를 css파일의 purple 값을 적용 
          size='small' --------------------------------> Button컴포넌트의 className 중 size 변수를 css파일의 small 값을 적용
          onClick = {test1}
        />

=> onClick = {test1( )} : 함수 호출
     onClick = {test1} : 함수를 전달

cnst test2 = ( ) => {
 return 5;
}

* const abc = test2( );
 => test2( ) 호출(실행)하여 abc에는 5를 저장함
 
* const def = test2; 
 => test2 함수 자체를 def 변수에 넣고 있어서 바로 호출하여 사용하지 X
 => def( ); -> test2 함수를 호출하여 실행
=======================================================================================
* 페이지를 띄울 때
 - App.jsx 파일에서 

<Routes path = '' element= {}>
	<Route path = '' element= {}></Route>
</Routes>
 이렇게 활용이 가능함.

* Route를 아래와 같이 중복으로 사용하면 두 컴포넌트를 함께 띄울 수 있음(같은 화면에 가능함.)
  컴포넌트에 접근하는 url은 바깥 Route와 안쪽 Route의 path로 나열 지정
  Route 중복으로 사용할 때 path = '' 두 개가 있으면 url 위 아래 합쳐져서 화면에 띄워줌
  안쪽 Route의 path에는 '/' 생략하고, 화면에 띄울 컴포넌트 명으로 작성
  바깥 컴포넌트에 <Oulet /> 컴포넌트를 사용하여 함께 열리는 컴포넌트의 위치를 지정

 ex) 
<Route path= ' / ' element= { <BasicLayout />}> -------------------> 화면에 보여질 큰 테두리 화면
  <Route path=' join ' element= {<Join />}> -----------------------------> 큰 테두리화면 속에 보여질 본문내용 부분 , url : localhost:5173/join
</ Route>
=======================================================================================
* const [joinData, setJoinData] = useState({
    memEmail : '',
    memPw : '',
    confirmPw : '', -----------------------------------------> spring에 없어도 상관X, 저장해서 memPw랑 같은지 비교 
    memName : '',
    memTel : '', //완성된 연락처(010-1111-2222)
    tel1 : '', //010 
    tel2 : '', //-1111
    tel3 : '', //-2222
    memAddr : '',
    addrDetail : ''
  });

=> 객체에 key값들 확인하기
=> spring에 있는 멤버변수와 key를 맞춰야 하지만 만약 없어도 오류 뜨지 않음. 없으면 스프링에서 받지 않을뿐임. 여기서 입력받은 값이 저장되는것이 더 중요하기 때문에 신경 X
=> memTel = `{tel1} - {tel2} - {tel3}`;
=================================================================================================
* 페이지 이동
<Link> 
 -> 글자 클릭 시 페이지 이동
 -> 화면에 밑줄 X , 글자색 원래 색으로 오게 하려면 reset.css에서 a 클래스로 text-decoration : none; color : black; 이런식으로 주기
 -> a 클래스로 주는 이유 : react Router의 Link는 HTML에서 a 태그로 변환되기 때문에

<useNavigate> -> 알아서 이동
=================================================================================================
* ...prev : 기존의 데이터 모두 복사
  [name] : value -> 특정 키만 덮어쓰기

ex)
if(name === 'tel1' || name === 'tel2' || name === 'tel3'){
      setJoinData(prev => 
        ({...prev, memTel : `${prev.tel1}-${prev.tel2}-${prev.tel3}`})
      )
    }

=> 만약 name의 값이 문자열 tel1과 같거나 tel2와 같거나 tel3과 같으면 state변경함수를 실행
prev 최신데이터를 받아서 기존의 데이터를 모두 복사하고, memTel에는 prev 최신데이터에 저장된 tel1을 뽑아내고, tel2, tel3도 뽑아내서 memTel키에 'tel1-tel2-tel3' 형식으로 합쳐진 전화번호로(문자열로) 저장한다.