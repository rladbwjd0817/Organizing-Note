<데이터모델과 SQL>

1. 정규화
 1) 개념
 - 데이터의 중복을 최소화하면서 테이블을 보다 잘 조직된 상태로 분해하는 과정
 - 정규화를 수행하면서 데이터의 입력, 수정, 삭제 성능은 일반적으로 올라가고, 조회성능은 대부분 많은 조인이 발생하면서 하락함.
 - 조회성능을 올리기 위해 반정규화를 수행

 - 이상현상 : 데이터를 입력, 수정, 삭제하는 과정에서 일관성이 깨질 수 있는 것
    -> 삽입이상 : 테이블에 데이터를 삽입할 때 의도하지 않은 정보까지 삽입해야 하는 현상
    -> 갱신이상 : 중복 저자오디어 있는 데이터 중 하나만 갱신하고 다른 하나를 갱신하지 않을 때 나나타는 데이터의 불일치 현상
    -> 삭제이상 : 테이블의 특정 데이터를 삭제할 때 의도하지 않은 정보까지 삭제되는 현상

 2) 제 1 정규화
 - 릴레이션의 속성값이 모두 원자값으로 구성
 - 중복값을 제거
 - 기본키를 설정
 - 하나의 속성값만을 가지고 있으며 유사한 속성이 반복되지 않는 상태 => 원자성 확보

 * 1차 정규화 수행 후의 관계
 - 하나의 엔터티 내에서 주식별자에 대한 일반 속서은 1:1 관계를 가져야 함.
 - 일대다 관계가 성립한다면 1차 정규화 대상.

 3) 제 2 정규화
 - 주식별자가 2개 이상으로 구성된 복합식별자인 경우 => 주식별자가 단일식별자일 때는 제 2 정규화가 피룡없으며 그 자체가 이미 제2정규화임
 - 함수종속성 : 일반 속성이 주식별자의 일부에만 종속성을 가질 때, 논리적 종속 관계를 가지는 성질
 - 이런 부분 함수종속성을 제거한 상태
 
 4)제 3 정규화
 - 이행함수종속성 : 주식별자가 아닌 일반 속성 간에 함수종속성이 존재할 때 
   ex) 집합 A, B, C가 있을 때 A -> B, B -> C 이면 A -> C가 성립 
 - 이행함수종속성이 제거된 상태
 - 3차 정규화의 수행결과 분리된 엔터티들은 서로 비식별자 관계가 됨.

2. 관계와 조인
 1) 개념
 (1) 관계 
  - 엔터티 또는 테이블 간의 논리적 연관성을 의미
  - 슈퍼타입/서브타입 - OOP(객체지향프로그래밍)에서의 상속관계와 유사한 것으로 슈퍼타입은 공통의 속성을 묶어 일반화환 상위 엔터티개념, 서브 타입은 개별적인 속성을 통해 특수화한 하위 엔터티 개념 => 물리 모델링 단계에서 조회성능 향상을 위해 변환이 필요
  - 정규화를 통해 분해된 테이블은 서로 관계를 맺음. 
  - 원래의 테이블이 가진 식별자 중 하나를 분해된 두 개의 테이블이 공통으로 가지게 되며, 하나가 다른 하나를 참조하는 형태
  - 존재적관계, 행위적 관계는 ERD에서 실선과 점선으로 구분하지 X

 (2) 조인 
  - 공통의 식별자를 가지는 두 개의 테이블을 하나로 합치는 것
  * INNER JOIN : 교집합, 기준이 되는 키에 따른 컬럼값이 존재하는 것만 병합
  * OUTER JOIN : 합집합, 기준키가 없더라도 모든 튜플(행) 병합
     -> LEFT OUTER JOIN : 왼쪽 테이블의 모든 행 포함시켜 조인
     -> RIGHT OUTER JOIN : 오른쪽 테이블의 모든 행 포함시켜 조인
     -> FULL OUTER JOIN : 왼쪽, 오른쪽 테이블의 모든 행 포함시켜 조인
  * NATURAL JOIN : JOIN 대상이 두 테이블의 같은 이름을 가진 컬럼에 대해서는 동일한 컬럼값을 가지는 행만 병합 -> ON 구조 X
  * CROSS JOIN : 왼쪽 테이블의 각 행에 대한 오른쪽 테이블의 모든 행의 대응을 조합하여 결과 출력 -> 기존 SELECT * FROM 테이블명
    
 * 반정규화 : 조회 시 조인이 발생하면 조회성능이 하락하므로 정규화와는 반대로 분해된 테이블들을 다시 합치거나 중복을 허용하여 재구성함으로써 조회 성능을 높일 수 있음. 데이터의 중복을 허용하거나 데이터를 그룹핑하여 조회성능을 높임.

 * 성능데이터 모델링
 - 데이터 모델링 시 정규화를 정확하게 수행
 - 데이터베이스 용량산정을 수행
 - 데이터베이스에 발생되는 트랜잭션의 유형을 파악
 - 용량과 트랜잭션의 유형에 따라 반정규화를 수행
 - 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행
 - 성능관점에서 데이터 모델을 검증

 * 슈퍼타입/서브타입 관계 변환 방법
 - One to One Type : 개별로 바생되는 트랜잭션에 대해서는 개별 테이블로 구성
 - Plus Type : 슈퍼타입 + 서브타입에 대해 발생되는 트랜잭션은 join 연산에 의한 성능저하를 가져오므로 슈퍼타입 + 서브타입 테이블로 구성
 - Single Type : 전체를 한번에 조회하는 트랜잭션은  union 연산에 의한 성능저하를 가져오므로 전체를 하나의 테이블로 통합

 (3) 자기 참조 관계
 - 하나의 테이블 내에서 한 속성이 다른 속성을 참조하는 관계
 - 계층형 데이터모델이라고 함. -> 계층형 질의나 셀프조인을 통해 원하는 결과를 조회할 수 있음.

 (4) 상호 배타적 관계(아크관계)
 - 둘 중 하나만 상속될 수 있는 관계
 - 보통 괄호와 유사한 선을 직접 그려줌.

3. 트랜잭션
 1) 개념
 - 데이터를 삽입, 수정, 삭제를 할 때 원자적으로 하나의 단위로 실행 -> 데이터의 정합성이 깨지지 X
 - 데이터를 읽고 쓸 때 한번에 수행되어야 하는 논리적인 작업 단위

 * 트랜잭션 관련 SQL 명령
  - COMMIT : 작업을 정상적으로 처리 완료하여 DB에 반영
 - ROLLBACK : 작업을 취소하고 이전 상태로 되돌림
 - SAVEPOINT : ROLLBACK시 부분작업 취소를 위한 저장점을 지정

 2) 특성 : 원-일-고-영
 - 원자성 : 하나의 트랜잭션으로 묶인 연산들은 'All or Nothing'의 개념으로 모두 실행되던지 아니면 전혀 실행되지 않아야 함.
 - 일관성 : 트랜잭션의 결과는 데이터베이스의 정합성을 깨지 않는다는 것, 트랜잭션 이전에 데이터베이스에 오류가 없다면 트랜잭션 이후에도 오류가 없음
 - 고립성 : 독립적으로 수행, 다른 트랜잭션이 실행 중간에 간섭하거나 영향을 미치지 않음.
 - 영속성(지속성) : 결과는 데이터베이스에 영구적으로 저장되어 유지

 3) 격리수준이 낮을 때 문제점
 - 트랜잭션 격리수준 : 쓰기작업 중에 읽기 작업을 어느 정도로 허용할지는 정하는 것.
 - Dirty Read : 트랜잭션에 의해 수저오디었으나 아직 커밋디 외지 않은 상태에서 다른 트랜잭션이 해당 데이터를 일겍 되면 발생하는 데이터의 불일치 현상
 - Non-Repeatable Read : 한 트랜잭션 내에서 같은 쿼리를 두 번 실행할 때, 그 사이에 다른 트랜잭션이 값을 수정하거나 삭제하면서 첫 번째와 두 번째 쿼리의 실행결과가 달라지는 현상
 - Phantom Read : 한 트랜잭션 내에서 같은 쿼리를 두 번 실행할 때 그 사이에 다른 트랜잭션이 값을 삽입하면서 두 번째 쿼리에서 이전에 없던 레코드가 나타나는 현상

4. NULL 속성
 1) 개념
 - 속성값을 말할 때 값이 아직 입력되지 않은 상태, 아무런 값도 가지고 있지 않은 상태
 - null != "null" 다름
 - 공백과도 다름
 - number 타입 속성의 경우에 값이 0인 것과 null 인 경우를 구분해야 함.
 
* Null 과의 연산
 - 단일행 연산 : null 값과의 연산 수행 결과는 null 임. -> 미정의된 값이기에 결과를 계산 X
 - 다중행 연산 : null 값인 행을 제외하고 연산을 수행 -> 미정의된 값으로 연산결과에 영향이 미치지 않도록 전체 연산 대상에서 제외

5. 본질식별자 vs 인조식별자
 1) 개념
 - 본질식별자 : 업무에 존재하는 원래의 식별자로 원조식별자라고도 함
 - 인조식별자 : 업무에 조냊하지 안흐안 원래의 식별자가 너무 복잡하게 구성되어 있어 인위적으로 만든 식별자로 대리식별자라고도 함.
 => 장점 : 개발의 편의성이 향상, 추가적인 연산없이 시퀀스 객체 사용 가능
 => 단점 : 데이터의 중복이 발생할 수 있고, 별도의 인덱스 생성 등이 필요
 => 개발의 편의성만을 추구하여 인조식별자의 사용을 쉽게 판단해서는 안되며 본질식별자의 구성이 너무 복잡해지는 경우에 장단점을 고려하여 신중하게 사용하는 것이 바람직함.

