<SQL 기본>
1. 관계형 데이터베이스의 개요
 1) 데이터베이스 
  : 데이터를 가공하여 유용한 정보를 얻고자 하는 것이며 이를 효율적으로 할 수 있는 방법을 연구하여 그 결과물로 만들어진 것
  - 데이터 : 컴퓨터로 어떤 일을 처리할 때 그 처리 대상이 되는 것
  - 데이터를 프로세싱(어떤 목적에 따라 가공)하여 유용한 정보로 변환하게 되면 그제서야 가치를 가짐
   => 수집한 사실 또는 값을 의미, 가공하여 유용하게 활용할 수 있게 만든 것을 정보 
  - 데이터를 일정한 체계에 따라 통합하여 디스크나 메모리에 저장한 것, 응용 프로그램에 종속적이지 않도록 일종의 미들웨어 형태로 만든 것
  - 장점 : 자료의 독립성, 중복저장의 최소화, 통합처리, 자체적 관리 기능
  - 필요성 : 파일을 통한 데이터 처리 과정에서 중복된 데이터의 저장에 따른 일관성 문제가 심각한 시스템 오류의 원인이 되었기 때문
  - DBMS(데이터베이스 관리 시스템) : 시스템 소프트웨어(데이터베이스를 구축하고 관리할 수 있는 기능을 제공), OS 위에 애플리케이션과 같이 설치하여 운영하는 것으로 시스템 소프트웨어와 응용 소프트웨어의 중간인 일종의 미들웨어

 2) 관계형 데이터베이스(RDB)
  - 데이터 일관성문제를 해결한 데이터베이스 시스템
  - 2차원 구조의 행과 열로 구성된 테이블 형태
  - 수학적 이론을 바탕으로 하고 있어 연산 자체를 수학적으로 최적화 할 수 있다는 장점
  - SQL에서 원하는 정보를 보다 쉽게 조회, 가공, 추출하는 것이 가능

 3)  TABLE(= 엔터티, 릴레이션)
  - 2차원 매트릭스 형태로 표현한 것
  - 열 = 필드(속성), 행 = 레코드(튜플) & 인스턴스, 칼럼 헤더 = 스키마
  
 4) SQL
  - 구조화된 질의 언어
  - 데이터를 제어할 수 있는 절차적 + 비절차적 언어
     -> 절차적 언어 : 데이터를 처리하는 과정을 HOW 관점에서 프로그래밍 할 수 있는 언어 ex) C, JAVA
     -> 비절차적 언어 : WHAT의 관점에서 절차를 명기하지 않고 원하는 결과만을 서술하는 언어

  (1) DDL(Data Definiton Language) : 데이터 정의어 (ex) CREATE, ALTER(이미 생성된 테이블의 구조(스키마) 변경), DROP, RENAME, TRUNCATE
    - 데이터의 구조(스키마)를 정의하는 명령어
    - ERD로 그려진 데이터 모델은 DDL과 상호 변환이 가능 
    - DDL 명령어의 경우 자동으로 COMMIT되면 트랜잭션이 완료되어 롤백이 불가능, but) 자동 COMMIT이 꺼지면 롤백 가능
    - COMMIT : 앞의 변경 사항을 디비에 영구적으로 반영하고 트랜잭션을 완료
    - ROLLBACK : 트랜잭션에 포함되는 전체 변경사항(이전의 커밋 명령 이후의 변경사항), 또는 지정된 저장점 이후의 변경 사항을 취소하고 원래대로 되돌림
    - SAVEPOINT : 롤백을 하기 위한 저장점을 지정, 롤백을 저장점을 지정하면 트랜잭션에 포함되는 전체 변경사항이 취소되는 것이 아니라 저장점 이후에 해당하는 변경사항만 취소

  (2) DML(Data Mainipulation Language) : 데이터 조작어 (ex) SELECT, UPDATE, INSERT, DELETE, MERGE
    - 데이터 조회, 입력, 수정, 삭제하는 명령어
    - commit 하기 전에 rollback 가능

 ★ DROP, TRUNCATE, DELETE의 차이점 ★
  - DROP : 스키마까지 완전히 삭제
  - TRUNCATE : 데이터만 삭제하고 스키마는 남겨 테이블을 초기화
    => 둘 다 디스크 저장공간을 릴리즈하여 재사용가능하게 하며 로그를 남기지 않음
  - DELETE : 테이블의 데이터를 모두 삭제하지만 저장공간을 릴리즈하지는 않음. DDL이 아니기에 롤백이 가능하고 로그를 남김
  - 동일 데이터를 삭제할 땐 TRUNCATE는 로그를 남기지 않는 등 작업취소를 위한 데이터를 생성하지 않으므로 DELETE보다 처리속도가 빠름

  (3) DCL(Data Control Language) : 데이터 제어어 (ex) GRANT, REVOKE
    - 사용자 접근권한과 같이 보안과 제어를 다루는 명령어

  (4) TCL(Transaction Control Language) : 트랜젝션 제어어 (ex) COMMIT, ROLLBACK, SAVEPOINT
    - 트랜잭션에 대한 제어를 다루는 명령어
    - DCL의 일부로 보기도 함

  * SAVEPOINT, ROLLBACK의 문법
    [Oracle 문법]
    - SAVEPOINT <이름>;
    - ROLLBACK TO <이름>;
    [SQL 문법]
    - SAVE TRANSACTION <이름>;
    - ROLLBACK TRANSACTION <이름>;
 
2. SELECT문
 - 데이터를 조회하는 명령어
 - WHERE절을 통해 특정 조건의 열만 조회
 - 별명 AS 뿌여할 수 있음
 [문법]
 SELECT 컬럼명
   FROM 테이블명; 

★ SELECT문을 이루는 절들의 실행순서 ★
FROM -> WHRER -> GROUP BY -> HAVING -> SELECT -> ORDER BY
 
 1) 산술연산자
   - 더하기, 곱하기 등 산술연산을 수행
   - 동일한 행에서 칼럼 대 칼럼의 연산을 수행
   - NULL과의 산술연산결과는 NULL이며 0으로 나누면 오류 발생
  * 연산 우선 순위
 ( ) -> * ,  /,  %(MOD 나머지연산) -> +, -
  
 2) 합성연산자
   - || : 문자열을 연결, 문자열 값 or 문자열 형의 칼럼에 대해 사용가능(단일행 연산)

3. 함수
 - 입력된 값에 대해서 어떤 연산을 수행한 후 그 결과를 반환하는 일련의 코드 덩어리
 - 내장함수(DBMS별로 이미 만들어져 제공) + 사용자정의 함수(사용자가 직접 SQL문을 작성해서 함수의 코드를 정의)
 - 내장함수 
   -> 단일행 함수 : 하나의 행에 대해서 연산을 수행한 후에 결과를 반환하는 함수, 각 행에 대해서 개별적으로 연산이 이루어짐
   -> 다중행 함수 : 여러 행에 대해서 연산을 수행하여 결과를 반환하는 함수, 집계함수, 그룹함수, 윈도우함수등이 해당

 1) 문자함수
  - 문자열을 대상으로 한 연산을 수행하는 함수
  (1) LOWER : 소문자 변환 ex) LOWER(컬럼명 or 문자열값)
  (2) UPPER : 대문자 변환 ex) UPPER(컬럼명 or 문자열값)
  (3) CHR(CHAR) : 아스키 코드값에 대응하는 문자를 반환 ex) CHR(아스키 코드값)
  (4) TRIM : 문자열 양 끝단에서 공백또는 지정된 문자열 제거 
     -> LEADING : 문자열 앞부분(왼쪽)에 있는 특정 문자나 공백을 제거 ex) TRIM(LEADING '가' FROM '가나다라') => 나다라
     -> TRAILING : 문자열 끝부분(오른쪽)에 있는 특정 문자나 공백을 제거 ex) TRIM(TRALIGIN '라' FROM '가나다라') => 가나다
     -> BOTH :  문자열의 앞과 뒤 양쪽 모두 지정된 문자나 공백을 제거, 생략될 경우 기본값으로 지정 ex) TRIM('    GOOD    ') FROM 테이블명 => GOOD 반환
  (5) LTRIM(=LEADING) : 문자열의 왼쪽 끝에서 공백 또는 지정된 문자열을 제거 ex) LTRIM('   GOOD') => GOOD, LTRIM('가나다라', '가') => 나다라
  (6) RTIRM(=TRALING) : 문자열의 오른쪽 끝에서 공백 또는 지정된 문자열 제거 ex) RTRIM('GOOD   ') => GOOD, RTRIM('가나다라', '라') => 가나다
  (7) SUBSTR : 입력된 문자열의 부분 문자열을 추출 ex)SUBSTR('Good Mornin', 1, 4) => 첫번째 문자부터 4글자 추출 : Good
  (8) LENGTH : 문자열의 길이를 반환 ex) LENGTH('GOOD') => 4
  (9) REPLACE : 입력된 문자열을에서 특정 문자열을 찾아 다른 문자열로 대체 ex) REPLACE('Good Morning', 'Morning', 'Afternoon') => Morning을 Afternoon으로 대체 : Good Afternoon

 2) 숫자함수
  (1) ABS : 절댓값반환 ex) ABS(-2.3) => 2.3
  (2) MOD : 나머지 값 반환 ex) MOD(9, 2) => 1
  (3) ROUND : 반올림 ex) ROUND(2.67, 1) =>2.7, ROUND(2.67) => 3
  (4) TRUNC : 반올림하지 않고 특정 자릿수에서 버림 ex) TRUNC(2.37, 1) => 2.3, TRUNC(2.37) => 2
  (5) SIGN : 입력된 값이 양수이면 1, 음수이면 -1, 0이면 0 을 반환 ex) SIGN(2.3) => 1 , SIGN(-2.3) => -1, SIGN(0) => 0
  (6) CEIL : 입력된 값보다 크거나 같은 최소의 정수를 반환 ex) CEIL(2.3) => 3
  (7) FLOOR : 입력된 값보다 작거나 같은 최대의 정수를 반환 ex) FLOOR(2.3) => 2
  (8) EXP, LOG, LN, POWER, SIN, COS, TAN 등 다양한 수학 함수들은 숫자형 데이터 타입을 인자로 받아서 해당 연산을 수행

 3) 날짜함수
  (1) SYSDATE : 오늘 날짜 년, 월, 일, 시간(시, 분, 초) ex)2026-02-21 21:00:11.000   
  (2) EXTRACT : 날짜로부터 년, 월, 일을 추출해서 반환
     -> YEAR / MONTH / DAY / HOUR / MINUTE / SECOND 
     -> ex) EXTRACT(MONTH FROM SYSDATE) => 오늘 날짜에서 월 추출 : 2

 4) 변환함수
  - 명시적 형변환 : TO_NUMBER, TO_CHAR, TO_DATE
  - 암시적 형변환 : DB내부에서 임의로 형변환을 수행, 성능저하를 가져오거나 에러가 발생할 때도 있으므로 주의해야함.
  
  (1) TO_NUMBER : 데이터 타입을 숫자형으로 변환 ex) TO_NUMBER('1001') => 1001
  (2) TO_CHAR : 문자열형으로 변환 ex) TO_CHAR(SYSDATE, 'YYYYMMDD') => 문자열로 오늘 날짜 출력 : 20260221 
  (3) TO_DATE : 날짜형으로 변환 ex) TO_DATE('20260221', 'YYYYMMDD') => 문자열값을 날짜형으로 출력 : 2026-02-21 00:00:00.000

 5) NULL 관련 함수
  (1) NVL(= ISNULL) : 첫번째 인자가 NULL이 아니면 첫번째 인자를 그대로 반환, NULL이면 두번째 인자를 반환, 첫번째와 두번째 인자의 데이터 타입은 같아야 함. ex) NVL(COMM, 0) => 컬럼 COMM에서 NULL인 것을 0으로 바꿈
  (2) NULLIF : 입력된 두 인자가 같으면 NULL을 반환, 다르면 첫번째 인자를 반환 ex) NULLIF(MGR, 7698) => MGR 컬럼의 값이 7698인 것을 NULL로 치환하여 반환
  (3) COALESCE : 입력된 인자를 순서대로 평가하여  NULL이 아닌 첫번째 인자를 반환 ex) COALESCE(NAME, AGE, SAL) => NAME, AGE, SAL 컬럼 순으로 읽어서 NULL이 아닌 첫 번째 값을 반환 : 비어있는 칸은 옆의 칸으로 이동해서 그 칸이 데이터가 있으면 그 데이터를 반환
 
 6) CASE(= DECODE) : 컬럼이 특정값을 가지면 이를 대체하는 새 값을 반환하는 연산
   ex) CASE
        WHEN 컬럼1 = 값1 THEN 값A
        ELSE 값N
        END
  
4. WHERE절
 - 특정 조건을 만족하는 행만을 대상으로 연산을 수행
 - 집계함수 사용 X
 - SELECT, UPDATE, DELETE에는 사용가능하나 INSERT문에서는 사용 X
 - ISNULL, IS NOT NULL만 사용 가능! (비교연산자를 이용한 조건식은 제대로 동작하지 X)
 
 1) 비교연산자
  - 두 값이 같은지를 비교하거나 크기를 비교하여 참, 거짓을 반환
  - 다중행인 경우 별도의 연산자 IN, EXISDTS, ALL, ANY를 사용

  (1) 단일행 연산자
   - = , < , <=, >, >=, IS NULL(NULL과 비교할 때만 IS 붙임)

  (2) 다중행 비교연산자
   - 서브쿼리를 사용할 때 더 유용하게 사용
   - IN : 리스트 중 동일한 값이 하나라도 있으면 참을 반환 (aka. OR연산자)
   - EXISTS : 서브쿼리 대상으로만 사용 가능, 서브쿼리의 결과가 한 건이라도 있으면 참을 반환
   - ALL : 리스트 각각의 원소와 비교하여 모두 참이면 참을 반환, 단일행 비교연산자와 결합하여 사용 (aka. AND연산자)
   - ANY : 리스트 각각의 원소와 비교한 결과가 하나라도 참이면 참을 반환, 단일행 비교 연산자와 결합하여 사용 (aka. OR연산자)

 2) 부정 비교연산자
  (1) 단일행 부정 비교연산자
   - 서로 다른지 비교할 때 사용
   - NULL 값 비교할 땐 IS NOT NULL을 사용
   - !=, ^=, <> : 두 값이 서로 다르면 참을 반환
   - IS NOT NULL : NULL이 아니면 참을 반환
 
  (2) 다중행 부정 비교연산자
   - IN, EXISTS 앞에 NOT을 붙임 ex) NOT IN, NOT EXISTS
   - ALL, ANY는 전체 조건식 앞에 NOT을 붙임
   *  IN은 OR, NOT IN 은 AND로 연결

 3) SQL 연산자
  - BETWEEN A AND B : A보다 크거나 같고, B보다 작거나 같다
  - LIKE : 문자 검색 시 사용
     -> % : 0개 이상의 문자
     -> _ : 임의의 문자 1개
   ex) LIKE '%M%' : 중간에 M이 있는 문자열
        LIKE '_M' : M으로 끝나는 길이가 2개인 문자열

 4) 부정 SQL 연산자
  - NOT BETWEEN A AND B :  A보다 작거나 B보다 크다
  - NOT LIKE : 패턴과 매칭되는 것이 하나도 없으면 참을 반환

 5) 논리 연산자
  - AND : 모든 조건이 참이면 참
  - OR : 하나라도 참이면 참
  - NOT : 뒤에 오는 식의 참/거짓의 반대를 반환

5. GROUP BY, HAVING절
 - 데이터 그룹핑
 - GROUP BY 연산이후에 조건 필터링을 수행하면 조회성능 나빠짐
 
 (1) 집계함수
  - GROUP BY절을 통해 데이터를 그룹핑한 다음에는 해당 그룹에 대해서 집계함수를 사용해서 개수, 합, 평균 등의 통계값을 계산
  - COUNT : NULL 인 행을 제외한 행의 갯수 
  - SUM : 컬럼의 합
  - AVG : 컬럼의 평균
  - MIN : 컬럼의 최솟값
  - MAX : 컬럼의 최댓값
  - DISTINCT : 중복제거

 (2) HAVING
  - 집계함수를 사용할 수 있는 조건절
  - GROUP BY절과 함께 사용하기도 하고 없이도 사용할 수 있음.

6. ORDER BY절
 - 정렬
 - 기본값은 ASC : 오름차순
 - DESC : 내림차순
 - GROUP BY절보다 논리적 실행 순서가 나중이므로 집계함수를 사용할 수 있음
 - NULL이 있을 경우 -> Oracle은 NULL 값을 최댓값, SQL은 최솟값 처리
 
7. 조인
 - 조인 : 두 개의 테이블을 하나로 병합하는 것
 - PK와 FK의 연관성에 의해서 성립하나 연광성이 없더라도 논리적인 값들의 연관만으로도 조인이 성립할 수 있음
 - 조회성능을 높이기 위해서는 조인이 덜 일어나도록 해야하고, 이때 수행하는 것이 반정규화임!

 1) INNER JOIN
  - 교집합
  
  (1) EQUI JOIN(= EQUAL)
   - =, 등식을 조건으로 사용할 때 발생하는 조인
   - 컬럼값이 정확하게 일치할 때 성립
   - WHERE절(ON절)의 조건이 등식인 경우 발생

  (2) NON EQUI JOIN
   - WHERE절의 조건이 등식이 아니라 부등식(BTWEEN, >, >=, <=, <)을 사용해서 범위를 나타낸 조건일 때 발생
   - 설계상의 이유로 실행이 불가능할 때도 있으니 주의해야 함

 2) 3개 이상 TABLE JOIN
  - 두 개의 테이블에 대해서 1번의 조인이 발생하므로 N개의 테이블에 대해서는 N-1만큼의 조인이 발생
  - 3개 이상의 테이블에 대한 조인은 조회성능이 매우 하락할 수 있어서 주의해야 함.
  - 반정규화를 통해 조인이 필요한 테이블의 개수를 줄여 성능을 최적화하는 것이 필요

 3) OUTER JOIN
  - LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN
  - 조인 조건에 맞지 않는 행까지 포괄적으로 병합
  - 합집합
  - WHERE절에서 JOIN 컬럼 옆에 (+)를 붙이면 OUTER JOIN이 됨
    ex) WHERE A.DEPTNO = B.DEPTNO(+) => (+)기호가 붙이 않은 쪽 테이블이 기준 테이블이 됨. = A LEFT OUTER JOIN B   

8. 표준 조인
- ANSI SQL의 문법에 따른 조인 쿼리
- 표준 조인에서는 기준 조건으로 WHERE이 아니라 ON절을 사용하여 FROM절에 조인의 종류를 명시

 1) INNER JOIN
  - 두 개의 테이블을 조인할 때 사용
  - 교집합 개념, 기준이 되는 키에 따른 컬럼값이 존재하는 것만 병합

 2) OUTER JOIN
  - 합집합 개념, 기준이 되는 키에 따른 컬럼값이 존재하지 않더라도 모든 튜플(행)을 병합
  - 조인의 대상이 되는 두개의 테이블을 각각 왼쪽 테이블, 오른쪽 테이블이라고 할 때 어떤 테이블의 행들을 모두 포함시킬 것인지에 따라 LEFT, RIGHT, FULL OUTER JOIN으로 구분됨 
 
  (1) LEFT OUTER JOIN
   - 왼쪽 테이블의 모든 행을 포함시키면서 JOIN
  (2) RIGHT OUTER JOIN
   - 오른쪽 테이블의 모든 행을 포함시키면서 JOIN
  (3) FULL OUTER JOIN
   - 왼쪽 테이블의 모든 행, 오른쪽 테이블의 모든 행을 포함하는 JOIN

 3) NATURAL JOIN
  - 조인의 대상이 되는 두 테이블에서 같은 이름의 컬럼에 대해서는 동일한 컬럼값을 가지는 행만 병합
  - SQL에서는 없음
  - JOIN에 이미 조건을 내표하고 있으므로 ON절을 사용 X, SELECT절의 컬럼명에도 테이블 별칭 함께 표시 X 

* Oracle에서는 USING절을 사용해서 원하는 컬럼에 대해서만 조인 조건이 되도록 할 수 있음
 ex) SELECT * FROM ACTOR JOIN APPR USING (ACTOR_NO); => ACTOR테이블과 APPR 테이블을 조인해서 ACTOR_NO가 같은 컬럼의 모든 데이터를 조회

 4) CROSS JOIN
  - 평소에 사용하는 조건없이 조회되는 것
  - 카데시안 곱 
  - 왼쪽 테이블이 M행, 오른쪽 테이블이 N행이면 M*N행이 됨
  - 조건이 별도로 지정되지 X