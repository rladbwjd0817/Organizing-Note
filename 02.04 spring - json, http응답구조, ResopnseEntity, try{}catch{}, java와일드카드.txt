<Spring>

1. json 
 - 얘도 자료형임
 - 서로 다른 프로그램에서 데이터를 주고받을 때 사용 가능한 데이터의 형태
 - 자바와 자바스크립트가 서로 데이터를 주고 받을 수 있게, 자바스트립트 객체를 베이스로 만든 ★문자★ 데이터!!

2. http 응답구조
 - 상태코드(status code) : 응답 상태를 알 수 있게 해줌, 200~500번대 숫자로 구성
     -> 200 (OK) : 요청성공
     -> 201 (Created) : 리소스 생성 제공(주로 POST 사용때 같이 사용)
     -> 204 (No Content) : 성공했지만 리턴할 본문 없음
     -> 3** : 리다이렉션(다른 위치로 이동 필요)

     <React에서 나는 오류>
     -> 400 (Bad Request) : 요청이 잘못됨(형식 오류)
     -> 401 (Unauthorized) : 인증 필요
     -> 403 (Forbidden) : 권한 없음
     -> 404 (Not Found) : 리소스 없음 

     <Spring에서 나는 오류>
     -> 500 (Internal Server Error) : 서버에서 에러 발생

 - header : http 응답에 대한 모든 부가 정보, key-value 형태 / 근데 잘 안씀
 - body :  실제 전송하는 데이터(json데이터, html, 이미지 등)

3. ResopnseEntity<>
 - 기본문법 : ResponseEntity.status(HttpStatus.상태코드).header( ).body( )
 - < > 안에 전달할 데이터의 자료형을 기입
 - http 응답을 이루는 status, header, body 3부분으로 나누어 세밀하게 제어할 수 있는 클래스
 - status, header, body에서 원하는 부분을 입맛대로 설정해서 응답겨로가를 전달할 수 있게 해줌.
 - API에서 사용 -> try{ } catch{ } 문에서 사용

ex) 
@GetMapping("")
  public ResponseEntity<?> getBoardList(SearchDTO searchDTO){
    try {
      log.info("게시글 목록 조회 기능 실행 중 입니당!");
      List<BoardDTO> list = boardService.getList(searchDTO);
     
     //return문에 사용해서 리액트에 전달
      return ResponseEntity.status(HttpStatus.OK).body(list); 
    }catch(Exception e){
      log.error("!!!게시글 목록 조회 중 오류 발생!!!");
      e.printStackTrace();
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("오류났어요!!");
    }
  }

4. try{ } catch(Exception e){ }
 - try는 if문과 비슷함. -> 순차적으로 실행하다가 그 구간에서 오류가나면 그 즉시 try 멈추고 바로 catch문 순차적으로 실행
 - try문 안에 기존에 실행하던 코드를 작성
 - catch문 : aka. react의 axios에서 사용하는 catch와 비슷함
 - Exception e  : 오류에 대한 모든 정보가 들어있음.
 - printStackTrace( ) : 오류나는 위치와 이유에 대해 알려줌.

5. Java 와일드카드
 - " ? " : 얘가 와일드카드임
 - ResponseEntity<?> 넣으면 오류없이 다 통과됨