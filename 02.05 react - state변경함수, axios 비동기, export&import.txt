<React>

1. state 변경함수
- state 변경함수 실행은 밑의 나머지 코드 해석 다하고 일괄적으로 처리
- 만약 state 변경함수가 여러개 실행되어도 한번만 리렌더링!!

[사용법]
 1) setCnt(cnt 변수에 저장할 값);
     => setCnt(7) : cnt 값을 7로 변경

 2) 함수형 업데이트 
  : setCnt( (이전 cnt 값 ) => {return cnt 변수에 저장할 값} )
   => setCnt((prev) => {return 7})
   => setCnt(prev => 7) : prev(이전데이터)에 7을 저장
 
 - 기존 state 변수에 return되는 데이터의 값으로 변경
 - 매개변수로 들어온 값이 동시에 전달할 때 동시에 값을 증가할 수 있기에 사용
 - prev에는 최신데이터가 저장
 - 화살표함수에서 실행문이 할 줄이지만 return문일 때는 { } 생략 X
   -> but, { }와 return 키워드를 함께 생략가능함.
   -> 객체 사용시 축약할 때 소괄호를 감싸야 오류가 사라짐!
   -> ex) setMember( prev => ({...prev, name : 'kim'}))

* React - 화살표 함수 return 규칙 *

1) 중괄호 { } 없으면 → 자동 return
   ex) setLikeCnt(prev => prev + 1)
   
2) 중괄호 { } 있으면 → return 필수!
   ex) setLikeCnt((prev) => {
         return prev + 1;
       })
   
3) 객체 반환 시 → 소괄호 ( ) 로 감싸기!
   ex) setMember(prev => ({...prev, name: 'kim'}))
   
4) return 없으면 undefined 반환됨!
   ex) setLikeCnt((prev) => {prev + 1})  // ❌ 화면에서 사라짐!

★ 핵심: { } 있으면 return 까먹지 말기!

* 일반 방식으로 state 변경 함수가 연속적으로 있으면 실행하는 중에 밑의 state 변경함수가 실행
 -> 정말 살짝 조금 늦게 실행된 밑의 데이터가 저장되어 화면에 출력

 ex)
const [cnt2, setCnt2] = useState(0);

onClick={(prev) => {
          console.log(cnt2)
          setCnt2(prev => prev + 1)  -------> 1
          console.log(cnt2)
          setCnt2(prev => prev + 1)  -------> 2
          console.log(cnt2)
        }}

 => prev가 이전 데이터를 강제로 가져온 것 이므로, 위의 prev1에 1이 저장
 => 그 상태가 유지되어 prev2에 +1 해서 최종적으로 prev엔 2가 저장
 
2. axios
 - 비동기 방식으로 동작
 * 비동기 : 코드 실행 시 결과를 기다리지 않고 다음 코드를 실행하며 산발적으로 실행됨.

 ex)
 const [stuInfo, setStuInfo] = useState({});

 const getData = () => {
    // 학번이 1001번인 학생의 정보를 조회
    axios.get('http://localhost:8080/students/1001')  ----------------------> 1
    .then(response => {
      setStuInfo(response.data);
    })
    .catch(error => console.log(error));

    // 조회한 학생의 성적정보를 조회
    axios.get(`http://localhost:8080/grades/${stuInfo.gardeNum}`)  ----------------------> 2
    .then(response => {})
    .catch(error => console.log(error));
  }
 => 함수 안에 axios가 2개 있으면 1번째 axios가 요청을 보냄(응답결과 기다리지 않음) -> 2번째 axios가 요청을 바로 보냄(응답결과 기다리지 않음) -> state 변경함수가 실행되어 undefined가 출력 

 [axios 다른 사용법]
 1)
 - await, async : axios를 비동기에서 동기방식으로 실행 동작을 변경할 수 있음
   -> await : axios 명령어 앞에 붙임(기다려!), 기다렸다가 응답결과를 받고 그 다음 코드 실행 
   -> async : axios 코드가 포함된 함수의 정의문 앞에 붙임
      ex) 
       const getData = '( ) => { }' : ''가 함수
       => const getData = async ( ) => { }
    => 이 방식을 사용하면 await 가 붙은 axios는 동기적으로 실행
    => async가 붙어버린 함수 자체는 비동기가 되어버림

Q. 그럼 async 가 붙은 함수는 언제 해석이 될까?


 2)
 - "비동기 -> 동기" 방식으로 바꿔서 사용하기 위한 방법
 - 요청을 보내고 나서 기다리지 않고 조회를 하려 가는 순간 state변경함수가 state 변수에 데이터를 저장해서 console에 출력하면 undefined가 출력됨
 - 함수안에 try{ } catch( e ){ } 문 사용해서 안에 await axios를 사용하여 state 변경함수가 state 변수에 응답에 대한 결과 데이터를 저장할 수 있음.
 - try{ } catch( e ){ } 사용하면 기존의 axios.get( ).then( ).catch( ); 문의 catch( )를 대체해서 사용가능
 
3. export , import
 - 사용하고자 하는 컴포넌트의 변수, 함수를 내보내거나 가져오는 것

 - export : 내보내기
 * 기본문법 : export const getList = ( ) => { }
   -> 내보낼 함수나 변수 앞에 export 작성

 * export default 컴포넌트명
   -> import 할 때 컴포넌트명은 마음대로 바꿀 수 없음.

 - import : 가져오기
 * 기본문법
 : import { 함수명, 변수명 } from '파일경로 / 파일명'
 = import {구조분해할당} from '파일경로 / 파일명'
   ex) import { age, test1 } from '../util/myMath'
     => myMath에서 age, test1을 ★객체형태★로 가져와서 쓸게!

     => ./  :현재 폴더, ../  :상위 폴더로 가세요
 
 : import * as fun from '../util/myMath'
  => db처럼 * 전체 데이터, as fun 은 fun 이 별칭   
