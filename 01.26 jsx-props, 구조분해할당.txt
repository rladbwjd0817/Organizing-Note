{}, [] -> 참조자료형

const [cnt, setCnt] = useState({ });

setCnt({ });

-> { } 서로 다른 두 객체가 생겨서 cnt에는 다른 주소값이 저장되어 값이 변경됨!

=====================================================================================
* props

- 형태가 객체임!
- 리액트의 부모 컴포넌트는 자식 컴포넌트에게 필요한 데이터를 전달 가능!
- 데이터가 한 방향으로만 흐름
- 부모 -> 자식 관계에서만 데이터 전달 가능
- 자식 -> 부모 , 자식 -> 자식 데이터 전달 X
- 태그의 속성역할처럼 사용함!
 ex) <Child myData={ }>

★ state 변경함수가 실행되면 state 변수가 선언된 컴포넌트가 리렌더링 됨!
★ state 변경함수가 실행되는 컴포넌트에서 자식 컴포넌트가 있으면 해당 자식 컴포넌트도 다 다시 리렌더링 됨!!
---------------------------------------------------------------------------------------------------------------------------------------------------------
* props + 구조분해할당

- 배열과 객체에서 사용가능한 문법
- 배열, 객체에 저장된 데이터를 편하게 사용하기 위한 문법

ex) 구조분해할당 사용X
  const arr1 = [1,2,3]; 
  const [a1, b1, c1] = arr1;
  console.log(a1); // -> 1출력  
---------------------------------------------------------------------------------------------------------------------------------------------------------

ex) 구조분해할당 
  const book{
      title : '셜록홈즈의 모험' ,
      author : '아서코난도일' ,
      brand : '북마크' ,
      stock : 10
  }

const bookTest = ({title, author, brand, stock}) => {
   console.log(title);
   console.log(author);
   console.log(brand);
   console.log(stock);
}
 => 객체를 구조분해할당을 사용했을 때 평소에 사용하던 객체명.변수명 이렇게 호출하는 것이 아니라 바로 변수명을 사용하여 호출이 가능함!
 => 대신 변수명은 key 값과 동일해야 함.

---------------------------------------------------------------------------------------------------------------------------------------------------------

★구조분해할당 배열과 객체 차이 ★
1) 배열은 순번 O, 객체는 순번 X 
 => 2) 그래서 배열은 변수명을 자유롭게 작성가능, 객체는 변수명은 key 값과 동일하게 작성
 => 객체는 key 값을 보고 같은 key의 value 값을 출력함.
 => 만약 key 값이 존재하지 않으면 undefined 출력
